# Практичне завдання 3

## Завдання 1

## Короткий опис проекту
Проект реалізує паралельний пошук елемента у двовимірному масиві, значення якого співпадає із сумою його індексів.

Користувач задає розміри масиву, а також діапазон значень його елементів. Масив заповнюється випадковими числами, після чого пошук виконується двома методами:
- **Work Dealing** (статичний розподіл роботи між потоками)
- **Work Stealing** (динамічний розподіл роботи через "крадіжку").

На екран виводяться:
- Згенерований масив
- Результати пошуку (або повідомлення про їх відсутність)
- Час виконання для кожного методу

## Відповіді на питання

### Чи є різниця у часі виконання?
Так, є суттєва різниця. У нашому випадку **Work Stealing** виконав завдання майже в чотири рази швидше за **Work Dealing**.

### Пояснення результатів
**Work Dealing** працює повільніше за **Work Stealing** через статичний розподіл задач між потоками. У **Work Dealing** кожен потік обробляє фіксований блок матриці. Якщо один потік завершує роботу раніше, він простоює, поки інші потоки ще зайняті.  
У **Work Stealing**, навпаки, потоки динамічно отримують нові завдання, якщо завершили свої, завдяки чому ресурси використовуються ефективніше, а час простою зводиться до мінімуму. Це робить його швидшим для нерівномірного або великого навантаження.

## Завдання 2

## Короткий опис проекту
Програма написана для пошуку зображень у вибраній користувачем директорії. Вона запитує шлях до директорії, перевіряє її на існування, після чого рекурсивно обходить файли й підкаталоги, використовуючи **Fork/Join Framework**. Зображення визначаються за їхніми розширеннями (.png, .jpg, .jpeg, .bmp, .gif). У підсумку програма виводить кількість знайдених зображень і відкриває останнє знайдене зображення.

## Відповіді на питання

### Поясніть чому обрали той чи інший підхід?
У цьому проекті використовується підхід Work Stealing. Він був обраний через такі переваги:
- **Динамічний розподіл завдань**
У випадку рекурсивного обходу файлової системи кількість підзадач не відома заздалегідь. Наприклад, у деяких директоріях може бути багато підкаталогів, а в інших — мало.
Work Stealing забезпечує гнучкий підхід, оскільки потоки можуть брати на себе додаткові завдання за потреби.

- **Ефективне використання ресурсів**
У Work Dealing, якщо потік завершує свою роботу раніше за інші, він просто простоює, навіть якщо інші потоки перевантажені. Work Stealing мінімізує цей простій, дозволяючи всім потокам залишатися максимально завантаженими.

- **Висока продуктивність на нерівномірних даних**
У файлових системах структура каталогів може бути дуже нерівномірною (одна директорія містить тисячі піддиректорій, а інша — лише кілька файлів).
Work Stealing автоматично адаптується до такого сценарію, розподіляючи навантаження між потоками під час виконання.

- **Мінімізація початкових витрат**
У Work Dealing всі завдання повинні бути розподілені на самому початку, що вимагає їхнього попереднього аналізу та створення. Work Stealing у Fork/Join Framework цього не потребує, оскільки завдання генеруються "на льоту".

